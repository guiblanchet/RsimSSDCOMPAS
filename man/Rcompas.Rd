% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rcompas.R
\name{Rcompas}
\alias{Rcompas}
\title{R version of simulation programs COMPAS and JCOMPAS}
\usage{
Rcompas(BETAA, X, G, MAJOR = FALSE, HISI, HQUAL, HQUANT, HCCA, HSYM, SAR, ...)
}
\arguments{
\item{BETAA}{A list. For each profile PX (each profile corresponds to a number of species chosen by the user), list of objects defining the parameter of the beta distribution for the species on the gradients. The names of the list objects contained in this list are PX$A,PX$m,PX$r,PX$alpha and PX$gamma. See the Details section for more precision on the usage.}

\item{X}{Matrix of environmental gradient(s).}

\item{G}{Guilds or groups. G is a logical vector: \code{TRUE} if species are prganized in guilds.}

\item{HISI}{Include or omit (0) the hypothesis of Inter-specific interaction. If included, HISI is a list with the following levels:
\itemize{
 \item \code{n} Number of interactions per species permitted (maximum, could be less because of subsequent rules). 999 means no limit.
 \item \code{g} Logical. Species must be from the same guild to interact.
 \item \code{mc} Must have similar modal coordinates, the proximity given by the user in percentage of the range of the gradient. If 999, than this rule does not apply.
 \item \code{mv} Must have similar modal value, the disimilarity given by the minimum gower distance. If 999, than this rule does not apply.
}}

\item{HQUAL}{Logical. Include or omit the hypothesis of qualitative noise, aka appearance probability. Applies to all species.}

\item{HQUANT}{Logical.}

\item{HCCA}{Logical. Include or omit ($type=0) the carrying capacity adjustment hypothesis. Other than 0 (no limit in carying capacity), this argument can take 3 other values : ($type=1) the stand abundance is constant over all the gradient (must be given in argument $parm) ($type=2) it is in a linear relationship with the gradients (intercept and slopes (in that order) must be provided in $parm as a vector) ($type=3) the carrying capacity is defined by a beta function with specified parameters ($A,$m,$r,$alpha,$gamma; provided in $parm). For this third option, the dipersion parameter of the distribution (if it exists), can be set to be fixed or proportional to a simple function of A by the user.Either way, the species abundances are rescaled accordingly.}

\item{HSYM}{Logical. Hypothesis of symmetry of the distribution for each profile. Provided by a vector of \code{TRUE} (symmetry) or \code{FALSE} (non symmetry, thus alpha and gamma are different) with one value per profile. If \code{TRUE}, alpha is simulated are the user has asked, and gamma is set to be equal to alpha.}

\item{SAR}{Logical. Add autocorrelation to species data or not.}

\item{\dots}{Further arguments for the autocorrelation application.}
}
\value{
A matrix giving the simulated species abundances
}
\description{
Generates species data that follows specific concepts and
hypotheses about the properties of the community patterns. Particularly,
concepts of asymetric physiological response (generalized beta distribution),
species guilds, interspecific interactions, carrying capacity, qualitative
noise (presence or absence of species at a particular site) and quantitative
noise (scatter around the fitted response) are integrated in the simulation
framework. It follows very closely the code from COMPAS Minchin(1987) and
JCOMPAS from Miquel de Caceres, January 2003. The main difference between
Rcompas and its two sister packages is that the explanatory variables must be
provided. This permits implemetation into \code{SimSSDR} for example, in
which autocorrelation can then be added to the species data. There is no
sampling design implemented.
}
\details{
As stated above, BETAA is a list of object describing the profile PX, where each profile corresponds to a number of species chosen by the user. Each profile is in turn a list of objects defining the parameter of the beta distribution for the species on the gradients. The names of the list objects contained in this list are PX$A,PX$m,PX$r,PX$alpha and PX$gamma. Two types of structure can be used for each of them, depending on if the user wants to specify the parameters himself or want them to be picked at random from a specific distribution. To simplify the following instructions, lets suppose that the object we're working on is 'A' in the list 'PARM' for a certain profile 'P' :

\itemize{
  \item For the first type, the value(s) is (are) set by the user. The first element of the list object states that the values are readily given by the user by stating the character string 'value'. The second and last element is the value(s) coerced in a vector. For example, we would have BETAA$P1$A<-list('value',c(1,2,3)) for 3 species having the A values 1, 2 and 3 respectivlely on one gradient. The extention to more than one gradient is given in the form of a list, see \code{examples}.
  \item For the second type, the values are chosen to be picked at random out of a specific distribution. The first element of the list object is then the character string 'random'. The user has to state two more elements to specify exactly from which distribution the parameters should be simulted. Thus the second element of the list is the name of the distribution (one of 'unifrandom', 'normal', 'lognormal', 'lograndom', 'exponential', 'gamma' or 'Poisson'). The third element contains the extra arguments needed to specify the parameters of the distribution, coerced in a vector. For example, BETAA$P1$A<-list('random','normal',c(n=2,mean=1,sd=0)). Note that the argument 'n' gives the number of species. See the 'BETA' function for more details on those (and other) parameters.
}
The user may define as many profiles as needed : one just has to provide them in the form of a list P1 - PX... . The number of species is stated in the arguments : for set values it's in the second element (ex : number of elements in the vector PARM$P$A[2]), and for the simulated ones, it's in the third (ex : n in PARM$P$A[3] = c(n=3,mean=0,sd=1)).
}
\note{
Guilds in Rcompas have certain particularities. Guilds can be simulated by expressively setting A0 the m parameters in the BETAA list. Also, the argument HSYM should be set to \code{FALSE} so major species in the guilds STAY in the guilds, and are not relocated on the gradient.
}
\examples{

#---------------------------------------------#
### Examples of how to build the BETAA list ###
#---------------------------------------------#

# *** In the case where we have many gradients, we need to specify the parameters for each gradients. This is done by extending the elements stated above into lists. Here are three examples. *** #

#-----------#
### Example 1
### Values specified by user for three gradients (2 species, 3 gradients)
#-----------#
BETAA<-list()
BETAA$P1$A <- list(list('value'), list(c(2,3)),list(n=2)) # On all 3 gradients, A0 is the same for the species.
BETAA$P1$m <- list(list('value','value','value'), list(c(2,4),c(3,3),c(6,4),list(n=2))) # On each gradient, the values are set. Again, for each gradient, we give the values for both species.

#-----------#
### Example 2
### Values picked at random for three gradients (2 species, 3 gradients)
#-----------#
BETAA<-list()
BETAA$P1$A <- list(list('random'), list('normal'), list(list(n=2,mean=1,sd=0))) # On all 3 gradients, A0 are the same for the species.
BETAA$P1$m <- list(list('random','random','random'), list('normal','lognormal','lognormal'), list(c(n=2,mean=1,sd=0),c(n=2, meanlog = 0, sdlog = 1),c(n=2, meanlog = 0, sdlog = 3))) # Two values are picked at random on the three gradients at random form different distributions. The distributions are the same for both species.

#-----------#
### Example 3
### A mixture of values set and picked at random from different distributions (2 species, 3 gradients)
#-----------#
BETAA<-list()
BETAA$P1$A <- list(list('random'), list('lognormal'), list(c(n=2, meanlog = 0, sdlog = 1)))
BETAA$P1$m <- list(list('value','random','random'), list(c(2,3),'lognormal','lognormal'), list(n=2,c(n=2, meanlog = 0, sdlog = 1)),list(n=2,c(n=2, meanlog = 1, sdlog = 3)))

#-----------#
### Example 4
### A complete example of how the list should be build
#-----------#
BETAA<-list() # 2 gradients
BETAA$P1$A<-list(list('value'), list(c(20,30,50)),list(c('n=3')))
BETAA$P1$m<-list(list('random','random'), list('normal','lognormal'), list(c('n=3,mean=50,sd=10'),c('n=3, meanlog = 0, sdlog = 1')))
BETAA$P1$r<-list(list('random','random'), list('normal','lognormal'), list(c('n=3,mean=20,sd=3'),c('n=3, meanlog = 4, sdlog = 1')))
BETAA$P1$alpha<-list(list('value','random'), list(c(2,3,4),'lognormal'), list(c('n=3'),c('n=3, meanlog = 0, sdlog = 1')))
BETAA$P1$gamma<-list(list('random','random'), list('normal','lognormal'), list(c('n=3,mean=0,sd=1'),c('n=3, meanlog = 0, sdlog = 1')))
BETAA$P2$A <- list(list('random'), list('normal'), list(c('n=2, mean=20, sd=1')))
BETAA$P2$m <- list(list('random','random'), list('normal','lognormal'), list(c('n=2,mean=30,sd=1'),c('n=2, meanlog = -1, sdlog = 1')))
BETAA$P2$r <- list(list('random','random'), list('normal','lognormal'), list(c('n=2,mean=20,sd=1'),c('n=2, meanlog = 2, sdlog = 1')))
BETAA$P2$alpha <- list(list('random','random'), list('normal','lognormal'), list(c('n=2,mean=0,sd=1'),c('n=2, meanlog = 0, sdlog = 1')))
BETAA$P2$gamma <- list(list('random','value'), list('normal',c(4,7)), list(c('n=2,mean=0,sd=1'),c('n=2')))

#-----------#
### Example 5
### Full examples of the main function usage using the last BETAA constructed
#-----------#

X<-cbind(c(1:100),c(rnorm(100)))
G<-c(TRUE,TRUE) # The two profiles are two guilds
MAJOR<-FALSE
HISI<-list(n=2,g=TRUE,mc=999,mv=999)
HQUAL<-TRUE
HQUANT<-TRUE
HCCA<-list(type=1,parm=10)
HSYM<-c(TRUE,TRUE) # For the two profiles
SAR=FALSE

Rcompas(BETAA=BETAA,X=X,G=G,MAJOR=MAJOR,HISI=HISI,HQUAL=HQUAL,HQUANT=HQUANT,HCCA=HCCA,HSYM=HSYM,SAR=SAR)

}
\references{
Minchin, P. R. 1987. Simulation of multidimensional community patterns: towards a comprehensive model. \emph{Plant Ecology} \strong{71}: 145-156.

de Cáceres, M. 2003. JCOMPAS. Dept. Biologia Vegetal, Universitat de Barcelona: JCOMPAS 1.0 user's manual.
}
\author{
Marie-Hélène Ouellette
}
\keyword{datagen}
